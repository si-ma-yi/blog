---
title: 루빅스 큐브 탐구 기록 - 커뮤테이터
pubDate: 2023-6-5
author: 匿名
tags:
  - 큐브
imgUrl: /images/루빅스큐브탐구기록-커뮤테이터/루빅스큐브.png
description: 루빅스 큐브의 커뮤테이터 대해 알아본 것을 기록해 둔다.
layout: "../../layouts/BlogPost.astro"
---

# 루빅스 큐브의 커뮤테이터에 대한 탐구

루빅스 큐브는 군 이론의 대표적인 예이다. 유튜브에서 보면 단 몇 초만에 맞추는 영상을 보면 그것도 엄청 신기하지만 나는 그것보다는 어떻게 블록들이 움직여서 결국 맞춘 상태로 가는건지가 더 궁금했다.

대학교 다닐 때 수학을 부전공 했지만 시간과 학점 문제 때문에 대수학 수업을 들어 본 적이 없어서 군 이론에 대하여 무지하지만 그래도 머리로 이해한 것을 정리 해두려고 한다.

## 큐브 조각 표기

| corner | edge |
| ------ | ---- |
| urf    | uf   |
| ufl    | ul   |
| ulb    | ub   |
| ubr    | ur   |
| dfr    | fl   |
| dlf    | lb   |
| dbl    | br   |
| drb    | df   |
|        | dl   |
|        | db   |
|        | dr   |

각 알파벳이 의미 하는 것은 해당 면이 어느 면인지를 의미한다.  
예를 들어 urf -> U 면의 오른쪽 앞 이다.
알파벳의 순서는 아무렇게나 써도 상관 없지만 그 순서가 초기 상태의 기준이 된다.  
예를 들어 urf -> ruf 면 u면 색이 r에 있는 상태이다.

## 회전 연산

U는 큐브 윗면을 시계방향으로 90도 돌리는 것이다. 조각은 아래와 같이 변환된다.

(urf -> ulb -> ubr -> urf), (ur -> uf -> ul -> ub)

우선 용어정리를 하자면

- 어떤 큐브 상태에 연산을 곱한다 -> 연산대로 돌린다. (X)
- 연산의 역원을 곱한다 -> 연산의 반대로 돌린다. (X')
- 연산들을 곱한다 -> 순서대로 연산대로 돌린다. (XYZ..)

333 큐브에는 아래와 같은 연산들이 있다. (역방향으로 돌리기 (X') 이나 두 레이어 돌리기(Xw) 시점 변환하기(x, y, z)는 표에서 제외함)

| operation | permutation                                        | cycle |
| --------- | -------------------------------------------------- | ----- |
| U         | (urf -> ufl -> ulb -> ubr), (ur -> uf -> ul -> ub) | 4     |
| D         | (rdf -> fdl -> ldb -> bdr), (dr -> df-> dl -> db)  | 4     |
| R         | (urf -> bru -> drb -> frd), (ur -> br -> dr -> fr) | 4     |
| L         | (ufl -> ulb -> ubr -> urf), (ul -> bl -> dl -> fl) | 4     |
| F         | (urf -> rdf -> dlf -> luf), (uf -> rf -> df -> lf) | 4     |
| B         | (ubr -> rbd -> dbl -> lbf), (ub -> rb -> db -> lb) | 4     |
| M         | (uf -> fd -> db -> bu)                             | 4     |
| S         | (ur -> rd -> dl -> lf)                             | 4     |
| E         | (fr -> lf -> bl -> rb)                             | 4     |

corner와 edge조각은 서로소이기 때문에 위와 같이 표한할 수 있다.
이다.

각 연산들은 4번 반복하면 초기 상태로 되돌아 온다. 이를 좀 더 세련되게 이야기 하면 cycle이 4 라고 표현한다.  
이 cycle수는 서로소인 변환들의 cycle의 최소 공배수이다.

여기서 드는 의문이 있는데 UR이나 RUR'U같이 여러 연산을 이어서 진행해도 cycle이 4가 될까?

## 여러 연산을 이어서 진행하는 경우

위에서 각각의 연산은 cycle이 4 이므로 4번 반복하면 제자리로 돌아온 다는 것을 알아냈다.

어떤 연산을 하고 그 반대로 다시 돌리면 제자리로 돌아온다는 것도 쉽게 알아 차릴 수 있다.

이 두가지를 기반으로 한번 생각 해보자.

### RU

RU연산은 cycle이 없다. RU를 계속 반복해도 큐브는 섞이기만 할 뿐 돌아오지 않는다. (위의 표처럼 직접 적어보면 알 수 있다. 귀찮아서 못적겠다.)

### RUR'U'

RU로 움직여진 블록들을 R'U'로 회수한다. 이때 모든 블록이 제자리로 돌아올까?

돌아오지 않는다. 순서대로 말로 풀어서 설명 해보겠다.

1. R연산이 윗면의 우측 상단 열의 블록들을 바꾼다. (퍼올린다)
2. U연산이 윗면의 우측 상단 열의 블록들을 바꾼다. (빼낸다)
3. R'연산이 윗면의 우측 상단 열의 블록들을 바꾼다. (퍼내린다)
4. U'연산이 윗면의 우측 상단 열의 블록들을 바꾼다. (다시 집어 넣는다)

이 때 윗면의 우측 상단열에 있던 블록들 끼리 뒤섞이게 된다. 우측 상단열과 관련이 없는 나머지 블록은 다시 제자리로 돌아오게 된다.

이 경우에는 몇 cycle일까? 모를땐 직접 써보는 것이 낫다.

| cubicles | R   | U   | R'  | U'  | description                            |
| -------- | --- | --- | --- | --- | -------------------------------------- |
| urf      | bru | rfu | rdf |     | <span style="color:red">changed</span> |
| ufl      |     | ulb |     | ufl |                                        |
| ulb      |     | ubr | fur | rub | <span style="color:red">changed</span> |
| ubr      | bdr |     | ubr | ulb | <span style="color:red">changed</span> |
| dfr      | fur | luf |     | fur | <span style="color:red">changed</span> |
| drb      | frd |     | drb |     |                                        |
| uf       |     | ul  |     | uf  |                                        |
| ul       |     | ub  |     | ul  |                                        |
| ub       |     | ur  | fr  |     | <span style="color:red">changed</span> |
| ur       | br  |     | ur  | ub  | <span style="color:red">changed</span> |
| fr       | ur  | uf  |     | ur  | <span style="color:red">changed</span> |
| br       | dr  |     | br  |     |                                        |
| dr       | fr  |     | dr  |     |                                        |

총 7개의 블록의 위치가 바뀌었고 블록 자체도 돌아가 있다(b의 색깔이 r에 있다던지 하는 경우)
이를 표현해 보면

- (urf -> rdf -> rfu) : 2 cycle
- (ulb -> rub -> bul) : 2 cycle
- (ubr -> ulb -> rub) : 2 cycle
- (dfr -> fur -> frd) : 2 cycle
- (ub -> fr -> ur -> ub) : 3 cycle

이므로 연산 RUR'U'는 각 연들의 최소공배수가 cycle이기 때문에 6이다. 6번을 해야 모두 제자리로 돌아온다. 실제로 해보면 RUR'U'를 6번 하면 원상 복구가 된다.

# 교환자(Commutator)

## 교환자의 형태

**XYX'Y**의 형태이다. 위에서 본 RUR'U도 커뮤테이터의 일종이다. 이를 자세히 생각해 보자

### 좀 더 자세히 생각 해 보자.

위의 RUR'U는 7조각이 자리가 바뀌었다. R과 U에 영향받는 조각이 7개이기 때문이다. 그 외의 조각들은 모두 제자리로 돌아왔다.

풀어서 써보자면 큐브의 오른쪽 면에 윗면의 다섯 조각이 빨려 들어가고 오른쪽 면 두 조각이 윗면으로 빨려 들어간다.

RUR'U에서 윗면은 두 번 블록을 공급하고 오른 쪽 면은 한번 올려 보낸다. **즉 서로 영향 받는 영역이 딱 한 영역이라면 그곳을 통해 블록이 2번, 1번 이동되어 3조각만 자리를 바꾸는 것이 가능하다** 는 것을 생각 해 볼수 있다.

이를 이용하여 대부분 알고리즘이 고안된다.

#### UFDF'U'FD'F

위의 commutator를 순서대로 살펴보자.

1. U연산이 윗면의 우측 상단 열의 블록들을 바꾼다. (집어 넣는다)
2. FDF'연산이 윗면의 한 블록과 아랫면의 한 블록의 자리를 바꾼 후 U면으로 돌려준다 (바꿔치기)
3. U'연산이 윗면의 우측 상단의 열의 블록들을 바꾼다. (빼낸다)
4. FD'F연산이 윗면의 한 블록과 2번 과정에서 바꿔치기 한 블록을 다시 U면으로 돌려준다 (원래대로 바꿔치기)

이 과정을 통해 아래 그림처럼 세 블록의 위치가 바뀌었다.

<img src="/blog/images/루빅스큐브탐구기록-커뮤테이터/UFDF'U'FD'F.png"  width="300" height="300">

자리가 바뀐 것 뿐 아니라 각 블록의 방향도 달라졌다. 이 상황을 orientation이 바뀌었다고 표현한다.

commutator가 블록 자체를 회전시키는 것도 규칙이 있어 보이는데 아마도 추측하건데 commutator를 이용하여 orientation도 정렬 할 수 있을 것 같은 강한 확신이 든다.

orientation에 대해서는 좀 더 알아보고 글을 써야 할 것 같다.

# 맺으며

개인적으로 소장하고 있는 큐브 관련 책과, 인터넷의 여러 글들을 토대로 공부 하였다. 참고자료는 아래 목록과 같다.

- https://m.blog.naver.com/psh951120/221755320586
- Handbook of cubik math
