---
title: 루빅스큐브 탐구 기록
pubDate: 2023-6-5
author: 匿名
tags:
  - 큐브
imgUrl: /images/루빅스큐브탐구기록/루빅스큐브.png
description: 루빅스큐브의 원리에 대해 알아본 것을 기록으로 남긴다.
layout: "../../layouts/BlogPost.astro"
---

# 루빅스 큐브의 수학적 원리에 대한 탐구
군 이론의 예로 루빅스 큐브를 많이들 든다. 하지만 나는 수학을 부전공 했지만 학점 때문에 대수학은 수업을 못들었기 떄문에(수업을 들었다고 해도 잘 모를 것이다.) 세련되게 수학적으로 적을 순 없지만 나름 정리해서 글로 남겨보려 한다. 

## 큐브 조각 표기

| corner | edge |
| ------ | ---- |
| urf    | uf   |
| ufl    | ul   |
| ulb    | ub   |
| ubr    | ur   |
| dfr    | fl   |
| dlf    | lb   |
| dbl    | br   |
| drb    | df   |
|        | dl   |
|        | db   |
|        | dr   |
   

각 알파벳이 의미 하는 것은 해당 면이 어느 면인지를 의미한다.  
예를 들어 urf -> U 면의 오른쪽 앞 이다.

## 회전 연산

U는 큐브 윗면을 시계방향으로 90도 돌리는 것이다. 조각은 아래와 같이 변환된다.

(urf -> ulb -> ubr -> urf), (ur -> uf -> ul -> ub)

U의 변환들의 최소공배수가 4이기 때문에 4cycle이다. 이를 한국말로 표현하면 4번만에 제자리로 온다는 것이다.  

333 큐브에는 아래와 같은 연산들이 있다. (역방향으로 돌리기 (X') 이나 두 레이어 돌리기(Xw) 시점 변환하기(x, y, z)는 표에서 제외함)

| operation | permutation | cycle|
| ------ | ---- | ----|
| U    |   (urf -> ufl -> ulb -> ubr), (ur -> uf -> ul -> ub) | 4|
| D    |  (rdf -> fdl -> ldb -> bdr), (dr -> df-> dl -> db)  | 4|
| R    | (urf -> bru -> drb -> frd), (ur -> br -> dr -> fr)   | 4|
| L    |  (ufl -> ulb -> ubr -> urf), (ul -> bl -> dl -> fl)  | 4|
| F    |   (urf -> rdf -> dlf -> luf), (uf -> rf -> df -> lf) |4 |
| B    |  (ubr -> rbd -> dbl -> lbf), (ub -> rb -> db -> lb)  |4 |
| M    |  (uf -> fd -> db -> bu)  |4 |
| S    |  (ur -> rd -> dl -> lf)  | 4|
| E    |  (fr -> lf -> bl -> rb)  |4 |

여기서 우선 용어정리를 하자면   
- 어떤 큐브 상태에 연산을 곱한다 -> 연산대로 돌린다.
- 연산의 역원을 곱한다 -> 연산의 반대로 돌린다(X')
- 연산들을 곱한다 -> 순서대로 연산대로 돌린다.  

corner와 edge조각은 서로소이기 때문에 위와 같이 표한할 수 있다.
이다.

다시 cycle얘기로 돌아와서 각 연산의 cycle은 모두 4로 동일한다. 그렇다면 UR이나 RUR'U같이 여러 연산을 진행해도 cycle이 4가 될까?

### 한번 생각해보자
각 연산대로 블록을 돌리면 블록을 어딘가로 보낸다. 이를 다시 반대로 블록을 돌리면 제자리로 돌아온다.   

그렇다면 RUR'U'같이 네 연산을 곱하게 되면 R을 하고 나서 윗면에 올라온 블록은 U로 인해 다른 곳으로 옮겨진다. 이 상태에서 R'을 하게 되면 앞서 U에 의해 움직이지 않던 블록, 즉 R에 의해서 움직였던 블로 중에 U에 의해 움직이 않은 블록이 제자리에 돌아오게 되고 이어서 U'를 하게 되면 U에 의해 움직였지만 R에 영향을 받지 않은 블록이 제자리로 오게 된다. 

이 경우에는 몇 cycle일까? 모를땐 직접 써보는 것이 낫다.

| cubicles | R    | U    | R'   | U'   | description |
| ------   | ---- | ---- | ---- | ---- | ----------- |
| urf      | bru  | rfu  | rdf  |      | <span style="color:red">changed</span>  |
| ufl      |      | ulb  |      | ufl  |             |
| ulb      |      | ubr  | fur  | rub  | <span style="color:red">changed</span>            |
| ubr      | bdr  |      | ubr  | ulb  |  <span style="color:red">changed</span>           |
| dfr      | fur  | luf  |      | fur  |  <span style="color:red">changed</span>           |
| drb      | frd  |      | drb  |      |             |
| uf       |      |  ul  |      |  uf  |             |
| ul       |      |  ub  |      |  ul  |             |
| ub       |      |  ur  |  fr  |      |    <span style="color:red">changed</span>         |
| ur       | br   |      |  ur  |  ub  | <span style="color:red">changed</span>            |
| fr       | ur   |  uf  |      |  ur  |    <span style="color:red">changed</span>         |
| br       | dr   |      |  br  |      |             |
| dr       | fr   |      |  dr  |      |             |

총 7개의 블록의 위치가 바뀌었고 블록 자체도 돌아가 있다(b의 색깔이 r에 있다던지 하는 경우)
이를 표현해 보면

- (urf -> rdf -> rfu) : 2 cycle
- (ulb -> rub -> bul) : 2 cycle
- (ubr -> ulb -> rub) : 2 cycle
- (dfr -> fur -> frd) : 2 cycle
- (ub -> fr -> ur -> ub) : 3 cycle

이므로 연산 RUR'U'는 각 연들의 최소공배수가 cycle이기 때문에 6이다. 6번을 해야 모두 제자리로 돌아온다. 실제로 해보면 RUR'U'를 6번 하면 원상 복구가 된다. 


# 교환자(Commutator)

## 교환자의 형태
**XYX'Y**의 형태이다. 위에서 본 RUR'U도 커뮤테이터의 일종이다. 이를 자세히 생각해 보자

### 자세히 생각 해 보자.

위의 RUR'U는 7조각이 자리가 바뀌었다. R과 U에 영향받는 조각이 7개이기 때문이다. 그 외의 조각들은 모두 제자리로 돌아왔다.  
풀어서 써보자면 큐브의 오른쪽 면에 윗면의 다섯 조각이 빨려 들어가고 오른쪽 면 두 조각이 윗면으로 빨려 들어간다.  
RUR'U에서 윗면은 두 번 블록을 공급하고 오른 쪽 면은 한번 올려 보낸다. 즉 서로 영향 받는 영역이 딱 한 영역이라면 그곳을 통해 블록이 2번, 1번 이동되어 3조각만 자리를 바꿀 수 있다는 생각을 해 볼 수 있다. 이를 이용하여 대부분 알고리즘이 고안된다. 

## 예시

